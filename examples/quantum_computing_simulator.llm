@copyright "MIT License" "2025 dbjwhs"
@language "C++"
@description "Build a comprehensive quantum computing simulator with advanced quantum algorithms"
@context "High-performance quantum state simulation with multi-threading and SIMD optimization"
@dependency "Eigen3, Intel MKL, CUDA (optional), OpenMP, HDF5"

@variable "max_qubits" "20"
@variable "precision_bits" "64"
@variable "thread_count" "8"
@variable "use_gpu" "true"
@variable "simulation_method" "state_vector"
@variable "decoherence_rate" "0.001"
@variable "gate_error_rate" "0.0001"

@architecture foundation "quantum_circuit" "Gate-based quantum computation model"
@architecture component "quantum_state" "representation: ${simulation_method}, precision: ${precision_bits}-bit"
@architecture component "gate_library" "universal_set: true, custom_gates: true, parametric: true"
@architecture component "measurement" "projective: true, weak: true, continuous: true"
@architecture component "noise_model" "decoherence: T1/T2, gate_errors: probabilistic"
@architecture component "optimizer" "simd: AVX512, threading: OpenMP, gpu: CUDA"

@architecture interaction "circuit_compilation" "optimization: true, decomposition: automatic"
@architecture interaction "error_correction" "codes: [\"surface\", \"color\", \"toric\"], syndrome_decoding: true"
@architecture interaction "variational_algorithms" "optimizers: [\"COBYLA\", \"SPSA\", \"Adam\"], gradients: parameter_shift"

@performance "Simulate ${max_qubits}-qubit circuits with 10^6 gates in minutes"
@complexity "O(2^n) space for n qubits, O(g * 2^n) time for g gates"
@security "Validate quantum circuit consistency, prevent invalid operations"

@constraint "Maintain unitarity of quantum evolution"
@constraint "Support both ideal and noisy quantum simulations"  
@constraint "Implement major quantum algorithms (Shor's, Grover's, VQE, QAOA)"
@constraint "Provide quantum-classical hybrid optimization"
@constraint "Export results to standard formats (OpenQASM, Cirq, Qiskit)"

@example "Quantum Teleportation Protocol" "
#include \"quantum_simulator.h\"

QuantumSimulator sim(${max_qubits});

// Create entangled Bell pair
QuantumCircuit circuit;
circuit.addGate(HadamardGate(1));  // Hadamard on qubit 1
circuit.addGate(CNOTGate(1, 2));   // CNOT: control=1, target=2

// Prepare state to teleport |ψ⟩ = α|0⟩ + β|1⟩
std::complex<double> alpha(0.6, 0.0);
std::complex<double> beta(0.8, 0.0);
circuit.addGate(StatePreparationGate(0, alpha, beta));

// Bell measurement on qubits 0 and 1
circuit.addGate(CNOTGate(0, 1));
circuit.addGate(HadamardGate(0));
auto measurement1 = circuit.addMeasurement(0);
auto measurement2 = circuit.addMeasurement(1);

// Conditional corrections on qubit 2
circuit.addConditionalGate(PauliXGate(2), measurement2);
circuit.addConditionalGate(PauliZGate(2), measurement1);

// Final measurement of teleported state
auto final_measurement = circuit.addMeasurement(2);

// Run simulation with noise model
NoiseModel noise;
noise.setDecoherenceRate(${decoherence_rate});
noise.setGateErrorRate(${gate_error_rate});

auto results = sim.execute(circuit, 1000, noise);
std::cout << \"Teleportation fidelity: \" << results.getFidelity() << std::endl;
"

@example "Variational Quantum Eigensolver (VQE)" "
// Solve H2 molecule ground state with VQE
MolecularHamiltonian H2 = MolecularHamiltonian::fromGeometry(
    \"H 0.0 0.0 0.0; H 0.0 0.0 0.74\", \"STO-3G\"
);

// Create ansatz circuit (UCCSD)
auto ansatz = UCCSDAnsatz(H2.getNumQubits(), H2.getNumElectrons());

// Classical optimizer
AdamOptimizer optimizer(learning_rate=0.01, max_iterations=1000);

// VQE algorithm
VQE vqe(sim, H2, ansatz, optimizer);
auto result = vqe.minimize();

std::cout << \"Ground state energy: \" << result.energy << \" Hartree\" << std::endl;
std::cout << \"Optimal parameters: \";
for (auto param : result.parameters) {
    std::cout << param << \" \";
}
"

@example "Quantum Error Correction" "
// Surface code error correction
SurfaceCode surface_code(5, 5);  // 5x5 logical qubit
auto encoded_circuit = surface_code.encodeLogicalZero();

// Add noise to the system
PhysicalNoiseModel physical_noise;
physical_noise.setDepolarizingRate(0.001);
physical_noise.setMeasurementErrorRate(0.01);

// Syndrome extraction and error correction
for (int cycle = 0; cycle < 10; ++cycle) {
    // Apply random errors
    encoded_circuit.addNoiseLayer(physical_noise);
    
    // Syndrome measurement
    auto syndromes = surface_code.measureSyndromes(encoded_circuit);
    
    // Decode errors using minimum-weight perfect matching
    auto corrections = surface_code.decodeErrors(syndromes);
    
    // Apply corrections
    for (auto correction : corrections) {
        encoded_circuit.addGate(correction);
    }
}

// Measure logical qubit
auto logical_measurement = surface_code.measureLogical(encoded_circuit);
std::cout << \"Logical error rate: \" << logical_measurement.errorRate() << std::endl;
"

@test "Test quantum gate implementations for unitarity"
@test "Test measurement statistics match theoretical predictions"
@test "Test Shor's algorithm factorization correctness"
@test "Test Grover's algorithm search amplification"
@test "Test VQE convergence for small molecules"
@test "Test quantum error correction syndrome detection"
@test "Test circuit optimization preserves functionality"
@test "Test noise model implementation accuracy"
@test "Test multi-threaded simulation consistency"
@test "Test GPU acceleration numerical equivalence"

@model "claude-3-opus"
@format "cpp"
@output_format "cpp"
@max_tokens "4000"
@temperature "0.1"
