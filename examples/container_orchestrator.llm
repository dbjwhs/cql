@copyright "MIT License" "2025 dbjwhs"
@language "Go"
@description "Build a container orchestrator with service discovery and load balancing"
@context "Cloud-native architecture with Kubernetes-like features"
@dependency "Docker API, etcd, Prometheus, gRPC"
@architecture foundation "microservices" "Distributed system with API-driven components"
@architecture component "scheduler" "algorithm: bin_packing, constraints: resource_aware"
@architecture component "service_mesh" "load_balancing: round_robin, health_checks: true"
@architecture component "storage" "volumes: persistent, secrets: encrypted"
@architecture component "networking" "overlay: vxlan, policies: network_policies"
@architecture interaction "leader_election" "algorithm: raft, failover: automatic"
@performance "Schedule 1000+ containers per second across 100+ nodes"
@complexity "O(nÂ²) for optimal scheduling, O(n log n) for heuristic scheduling"
@variable "max_pods_per_node" "110"
@variable "health_check_interval" "30"
@variable "leader_election_timeout" "15"
@variable "scheduler_interval" "1"
@example "Container Deployment" "
package main

import (
    \"container-orchestrator/api\"
    \"container-orchestrator/scheduler\"
)

func main() {
    // Initialize orchestrator
    orchestrator := api.NewOrchestrator()
    
    // Define deployment
    deployment := &api.Deployment{
        Name: \"web-server\",
        Replicas: 3,
        Containers: []api.Container{{
            Image: \"nginx:latest\",
            Resources: api.Resources{
                CPU:    \"100m\",
                Memory: \"128Mi\",
            },
            Ports: []api.Port{{
                ContainerPort: 80,
                Protocol: \"TCP\",
            }},
        }},
        Strategy: api.RollingUpdate{
            MaxSurge: \"25%\",
            MaxUnavailable: \"25%\",
        },
    }
    
    // Deploy and expose service
    err := orchestrator.Deploy(deployment)
    if err != nil {
        panic(err)
    }
    
    // Create service with load balancer
    service := &api.Service{
        Name: \"web-server-svc\",
        Selector: map[string]string{\"app\": \"web-server\"},
        Ports: []api.ServicePort{{
            Port: 80,
            TargetPort: 80,
        }},
        Type: api.LoadBalancer,
    }
    
    orchestrator.ExposeService(service)
}
"
@test "Test pod scheduling across multiple nodes"
@test "Test service discovery and DNS resolution"
@test "Test rolling deployments with zero downtime"
@test "Test node failure recovery"
@test "Test resource quota enforcement"
@constraint "Support horizontal pod autoscaling"
@constraint "Implement graceful shutdown for all components"
@constraint "Maintain backward compatibility with Docker"
@security "mTLS for inter-service communication, RBAC for API access"
@model "claude-3-sonnet"
@output_format "golang"